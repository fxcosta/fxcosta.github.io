<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Felix Costa | Full-stack Developer]]></title><description><![CDATA[Felix Costa - Full-stack Developer]]></description><link>https://fxcosta.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Wed, 26 Jul 2017 06:10:42 GMT</lastBuildDate><item><title><![CDATA[Iniciando com TDD #1 - Minha motivação e primeiro contato]]></title><description><![CDATA[E aí, pessoal! Esse artigo foi escrito originalmente para o  Blog PHP-BA , então confere lá e aproveita que tem bastante conteúdo...]]></description><link>undefined/blog/iniciando-com-tdd-1-minha-motivacao-e-primeiro-contato/</link><guid isPermaLink="false">undefined/blog/iniciando-com-tdd-1-minha-motivacao-e-primeiro-contato/</guid><pubDate>Sat, 09 Apr 2016 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;E aí, pessoal!&lt;/p&gt;
&lt;p&gt;Esse artigo foi escrito originalmente para o &lt;a href=&quot;http://phpba.com.br/iniciando-com-tdd-1/&quot;&gt;Blog PHP-BA&lt;/a&gt;, então confere lá e aproveita que tem bastante conteúdo interessante. Valeu, galera da comunidade PHP-BA!&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Dual Boot W8ponto1 e Mint em um Acer Aspire E14]]></title><description><![CDATA[Esse post é mais como uma dica porque encontrei algumas dificuldades para montar um ambiente com Windows 8.1 e Linux Mint 17.2. Nunca tinha...]]></description><link>undefined/blog/dual-boot-w8ponto1-e-mint-em-um-acer-aspire-e14/</link><guid isPermaLink="false">undefined/blog/dual-boot-w8ponto1-e-mint-em-um-acer-aspire-e14/</guid><pubDate>Mon, 28 Dec 2015 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Esse post é mais como uma dica porque encontrei algumas dificuldades para montar um ambiente com Windows 8.1 e Linux Mint 17.2.&lt;/p&gt;
&lt;p&gt;Nunca tinha trabalhado com um notebook mais recente que já tivesse vindo com o W8 de fábrica e com UEFI, por isso, tive um certo trabalho para encontrar uma solução, uma vez que, se você chegou até aqui, sabe que é de fato trabalhoso, ainda mais quando não se está tão acostumado com um ambiente Linux.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;O motivo de ter um Dual Boot é simples: Linux para trabalhar (programar, pesquisar, etc) e Win32 para jogar. Simples. Por incrível que pareça, ficou mais fácil jogar algo, já que eu sempre ficava na promessa de testar um novo jogo.&lt;/p&gt;
&lt;p&gt;Enfim, o modelo do notebook onde foi testado foi o Acer Aspire E14 (E5-471) com Windows 8.1 de fábrica. O método usado foi exatamente o mesmo que é encontrado em alguns artigos: primeiro dimensionar o HD para termos um espaço livre para nossa distro Linux, usar um LiveCD ou USB bootável, instalar a sua distro (que no meu caso foi o Mint 17.2) no espaço livre e… e aí, dependendo do seu notebook, como eu pude perceber, pode haver diversas situações.&lt;/p&gt;
&lt;p&gt;A minha situação foi: não havia um GRUB no momento de boot do notebook. Ou seja, ou iniciava direto pra um sistema ou por outro. O que definia qual sistema seria iniciado era a opção de boot escolhida. Se fosse UEFI iniciava o Windows, se não fosse, iniciava direto no Mint.&lt;/p&gt;
&lt;p&gt;A solução, a única que funcionou de todas as demais que testei, e que não foram poucas, foi a apresenta nesse vídeo:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.youtube.com/watch?v=3QOfYC4LJRo&quot;&gt;http://www.youtube.com/watch?v=3QOfYC4LJRo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Que é basicamente desativar o UEFI, entrar no Linux, instalar e rodar um script chamado &lt;a href=&quot;http://www.rodsbooks.com/refind/&quot;&gt;rEFInd&lt;/a&gt;, voltar a opção de boot para UEFI e pronto, no próximo boot teremos uma tela de escolha de qual sistema você deseja dar partida.&lt;/p&gt;
&lt;p&gt;Sem mais delongas é isso, fica apenas como uma dica para quem tem esse problemas - e pude perceber que não são poucas - e, caso tenha dado certo ou dado errado comenta para descobrir se de fato é a melhor alternativa.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Por que devemos preferir composição ao invés de herança?]]></title><description><![CDATA[Logo quando estamos começando nossa longa caminhada sobre os vales escuros da orientação a objetos - e digo escuro por que cada dia que...]]></description><link>undefined/blog/por-que-devemos-preferir-composicao-ao-inves-de-heranca/</link><guid isPermaLink="false">undefined/blog/por-que-devemos-preferir-composicao-ao-inves-de-heranca/</guid><pubDate>Sun, 06 Sep 2015 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Logo quando estamos começando nossa longa caminhada sobre os vales escuros da orientação a objetos - e digo escuro por que cada dia que passa se aprende mais - aprendemos o uso e importância da herança. Se você está lendo esse artigo suponho que ao menos já tenha visto uma situação onde você viu ou implementou herança.&lt;/p&gt;
&lt;p&gt;Mas, será que minha classe realmente É-UM outra classe? Será que eu realmente tenho que adotar tais comportamentos e até mesmo sobrescreve-los? Será que a classe filha realmente precisa de todos esses métodos e não somente de um ou dois? Se a herança é ferramenta básica de extensão e reuso de funcionalidade por que seu uso é extremamente desencorajado? Bem, vamos começar por partes.&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;Vamos ser diretos e listar os problemas da herança - levando em consideração que o leitor tenha noção da herança, seu objetivo e motivação. Primeiro ponto, inquestionável é: herança quebra o encapsulamento. Mas hein?&lt;/p&gt;
&lt;p&gt;Para essa afirmação vamos usar um exemplo claro, sem códigos ainda: Temos uma super classe chamada Dispositivo. Atualmente há duas classes derivadas de Dispositivo chamadas DispositivoA e DispositivoB e, logicamente, ambas herdam todos os métodos de Dispositivo mas vamos pegar um para exemplo que é chamado de conectarEntrada que é responsável pela lógica de como os dipositivos são conectados.&lt;/p&gt;
&lt;p&gt;Em nossa abstração - e ingenuidade - definimos o corpo desse método em Dispositivo e nas classes derivadas apenas nos referenciamos a ele, afinal, é o mesmo comportamento, não é? Porém, requisitos mudam e agora passamos a ter um novo tipo de dispositivo, o DispositivoC onde seu modo de entrada será diferente. A primeira coisa que pensamos é: ok, irei sobrescrever o método conectarEntrada, fazendo apenas os ajustes necessários. Obviamente o que você precisa? Conhecer como a super classe implementa esse método, daí você abre a classe, observa o que tem e comete a quebra do encapsulamento. Acabou encapsulamento, você violou um dos pilares da OO. Você tem conhecimento especifico demais.&lt;/p&gt;
&lt;p&gt;E isso fica pior quando DispositivoC não usa metade dos métodos de Dispositivo mas mesmo assim continuamos a trabalhar com a herança afinal alguns métodos ainda são aproveitáveis. Comodismo?&lt;/p&gt;
&lt;p&gt;Resumindo, o encapsulamento entre Dispositivos e DispositivoA, B e C é fraco, e o acoplamento é forte. Assim, toda vez que Dispositivo for alterado todas as subclasses serão afetadas. A nossa estrutura está presa, acoplada, e não pode sofrer alterações graves. Mas requisitos mudam, e nossos clientes não estão nenhum pouco preocupados com isso.&lt;/p&gt;
&lt;p&gt;E isso não é novidade, vide o artigo de Alan Snyder, &lt;a href=&quot;http://citeseer.ist.psu.edu/513482.html&quot;&gt;Encapsulation and Inheritance in Object-Oriented Programming Languages&lt;/a&gt;, de 1986! Não convencido? Olha o que a &lt;a href=&quot;https://en.wikipedia.org/wiki/Design_Patterns&quot;&gt;Gang of Four&lt;/a&gt; diz: “Porque herança expõe para uma subclasse detalhes da implementação do seu pai, por isso muitas vezes é dito que “herança é quebra de encapsulamento”.&lt;/p&gt;
&lt;p&gt;Beleza, então se você tá falando que esse lance de herança deve ser analisada com muito, mas muito cuidado, que solução usar? Joshua Bloch em seu livro Effective Java nos diz: prefira composição em vez de herança. Vamos ver isso melhor!&lt;/p&gt;
&lt;p&gt;Quando utilizamos composição, instanciamos a classe que desejamos dentro de nosso código, ex: DispositivoC não herda mais de Dispositivo, ele não É-UM Dispositivo, ele TEM um Dispositivo. Dessa forma, estamos estendendo as responsabilidades pela delegação de trabalho a outros objetos, ou seja, DispositivoA tem um comportamento parecido com Dispositivo? Beleza, simplesmente use o comportamento de Dispositivo ao invés de ter essa responsabilidade em DispositivoA.&lt;/p&gt;
&lt;p&gt;Ou seja, é um modo mais geral de estender uma classe, onde um objeto, em vez de realizar uma de suas tarefas, delega tal tarefa a um objeto auxiliar associado, que no caso você usaria como classe pai.&lt;/p&gt;
&lt;p&gt;Ao utilizar a composição, teremos muito mais flexibilidade, além de ser mais comum em muitos padrões de projetos. Dessa forma temos projeto mais flexível a mudanças, respeitando os princípios de responsabilidade única, substituição de Liskov e tornando nosso código desacoplado. Qualquer alteração feita em Dispositivo não quebrará nossos clientes diretamente e podemos usar somente métodos que sejam realmente necessários.&lt;/p&gt;
&lt;p&gt;Hum, não entendi muito bem ainda, mas já que você está falando vou usar somente composição! Não, aí é que entra o erro. A herança é sim útil, mas somente caso faça sentido o relacionamento É-UM. Meu exemplo pode ser citado como um mal exemplo por que da mesma forma como ele serve para ilustrar uma desvantagem no uso de herança ele pode ser exatamente a solução. Tudo depende do seu projeto e é por isso que vou listar quais benefícios e desvantagens de cada um deles:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Benefícios da herança:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Reusa tudo o que é comum nas classes relacionadas e isola o que for diferente.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A herança é vista diretamente no código&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Desenvolvimento mais rápido em comparação com composição caso os problemas da herança não sejam um problema para sua aplicação.
&lt;strong&gt;Problemas da herança:&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;O encapsulamento entre classes e subclasses é fraco (o acoplamento é forte). Ou seja, mudar da superclasse pode afetar todas as subclasses além de violar um dos princípios da OO que é manter um fraco acoplamento.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Às vezes um objeto precisa ser de uma classe diferente em momentos diferentes e com herança isso não é possível. Imagine que usamos herança no caso do DispositivoC. Mas puts, agora faz mais sentido que ele se comporte como DispositivosPaiTipoC. Como alterar isso se estamos parafusados já com a herança? Vamos ter que quebrar todos os clientes e refatorar tudo.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Relacionamento estático.
&lt;strong&gt;Benefícios da composição:&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;O comportamento pode ser escolhido em tempo de execução em vez de estar amarrado em tempo de compilação.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Melhorarmos nossa abstração trabalhando com interfaces.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Detalhes internos dos objetos instanciados não são visíveis.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Respeitamos o princípio da responsabilidade única, uma vez que uma determinada ação é responsabilidade da classe pai e não necessariamente preciso impor essa responsabilidade em suas classes derivadas.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Respeito ao princípio da substituição de Liskov, uma vez que é muito fácil eu quebrar esse princípio com um override que seja mais forte que o método padrão da classe pai.
&lt;strong&gt;Problemas da composição:&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Não diria que o software fica mais complexo, mas você deverá estar mais atento ao design da sua aplicação e isso irá requerer um melhor planejamento das classes que terão dependências de outras classes e etc.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Caso não seja o caso necessário, terá complexidade desnecessária a aplicação e isso acarretará a maior prazo de entrega do mesmo se for o caso.
Resumindo se o objeto “é um tipo especial de” e não “um papel assumido por, se o objeto nunca tem que mudar para outra classe futuramente e/o a subclasse estende a superclasse mas não faz override ou anulação de variáveis e/ou métodos, use herança, do contrário, fuga desse problema!&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Qualquer feedback, sugestão, erros (e isso é bem possível), críticas ou qualquer coisa do tipo, deixe seu comentário ou manda um e-mail!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Referências e fontes de estudo&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.berniesumption.com/software/inheritance-is-evil-and-must-be-destroyed/&quot;&gt;berniesumption&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.dsc.ufcg.edu.br/~jacques/cursos/map/html/pat/herancavscomposicao.htm&quot;&gt;UFCG&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.caelum.com.br/como-nao-aprender-orientacao-a-objetos-heranca/&quot;&gt;Caelum&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://imasters.com.br/artigo/20380/java/heranca-x-composicao/&quot;&gt;iMasters&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Design_Patterns&quot;&gt;Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://groselhas.maurogeorge.com.br/prefira-composicao-ao-inves-de-heranca-um-simples-exemplo-em-ruby.html#sthash.IXxGlACd.dpbs&quot;&gt;maurogeorge&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://marcionorberto.blogspot.com.br/2013/04/heranca-e-delegacao.html&quot;&gt;marcionorberto&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.devmedia.com.br/heranca-versus-composicao-qual-utilizar/26145&quot;&gt;DevMedia&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Diferença entre API e Web Service de maneira simples]]></title><description><![CDATA[Confesso que essa era uma pergunta que me intrigava. Eu via o conceito dos dois, conversas sobre os dois, mas ainda não tinha entendido qual...]]></description><link>undefined/blog/diferenca-entre-api-e-web-service-de-maneira-simples/</link><guid isPermaLink="false">undefined/blog/diferenca-entre-api-e-web-service-de-maneira-simples/</guid><pubDate>Sun, 31 May 2015 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Confesso que essa era uma pergunta que me intrigava. Eu via o conceito dos dois, conversas sobre os dois, mas ainda não tinha entendido qual a diferença entre eles e quando se referenciar a um ou a outro.&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;Pois bem, basicamente é o seguinte:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;API (Application Programming Interface)&lt;/strong&gt; - É como uma interface entre dois programas diferentes de modo que eles possam se comunicar um com o outro. Ou seja, uma API é a forma que terceiros disponibilizam uma interface de modo que possamos consumir um determinado serviço deles sem nos preocuparmos com a implementação do mesmo. As API podem usar qualquer meio de comunicação para iniciar a interação entre as aplicações. Por exemplo, as chamadas de sistema (System Calls) são invocados usando interrupções da API do kernel Linux.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Web Services&lt;/strong&gt; -  é uma interface projetada para se comunicar via rede. É uma API que usa obrigatoriamente a rede. Tipicamente, HTTP é o protocolo mais comumente usado para a comunicação. Web Services também usam SOAP, REST e XML-RPC como meio de comunicação. Ou seja, quando uma API precisa enviar dados através de rede, estamos falando de Web Services.&lt;/p&gt;
&lt;p&gt;Só que é preciso estar atento a alguns detalhes. Uma API geralmente envolve chamar funções de dentro de um programa. Por exemplo, as aplicações de desktop, como planilhas e documentos de texto usam VBA e APIs baseados em COM que não envolvem a Web e mesmo aplicações de servidor como o Joomla podem usar uma API PHP presente no próprio servidor sem necessidade da rede.&lt;/p&gt;
&lt;p&gt;Ou seja, resumindo de maneira bem simples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Todos os Web Services são API. Mas nem todas as API são Web Service.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Web Services podem não executar todas as tarefas que uma API normalmente realiza (ou pode realizar).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Um serviço Web utiliza apenas três estilos de comunicação: SOAP, REST e XML-RPC enquanto que a API pode usar qualquer estilo de comunicação.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Um Web Service sempre precisa de uma rede para o seu funcionamento enquanto uma API não precisa.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Uma API facilita a interface direta com um aplicativo enquanto que um Web Service é uma aplicação.
&lt;strong&gt;Referências&lt;/strong&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://pt.wikipedia.org/wiki/Web_service&quot;&gt;Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://www.differencebetween.net/technology/internet/difference-between-api-and-web-service/&quot;&gt;Difference Between&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://pt.stackoverflow.com/questions/17501/qual-%C3%A9-a-diferen%C3%A7a-de-api-biblioteca-e-framework&quot;&gt;StackOverflow&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item></channel></rss>